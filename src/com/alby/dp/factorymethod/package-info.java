/**
 * Created by xianwei on 2015/11/29.
 * 工厂方法模式
 * 定义：
 * <p>
 *        定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例
 *    化延迟到其子类
 *
 *  结构和说明
 *          Product                 Creator
 *              |                       |
 *          ConcreteProduct  <------ ConcreteCreator
 *     Product：定义工厂方法所创建的对象的接口，也就是实际需要使用的对象的接口
 *     ConcreteProduct：具体的Product接口的实现对象
 *     Creator：创建器，声明工厂方法
 *     ConcreteCreator：具体创建器对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例
 *   实例代码
 *     com.alby.dp.factorymethod.example1
 * 案例
 *      实现一个导出数据的应用框架，来让客户选择数据的导出方式，并真正执行数据导出。
 *      通常这种系统，在导出数据上，会有一些约定的格式，比如到处成：文本格式、数据库备份形式、
 *      Excel格式、Xml格式等等
 *    不用模式方案：   com.alby.dp.factorymethod.example2
 *          存在问题
 *              对于实现导出数据的业务功能对象，他需要创建ExportFileApi的具体实例对象，但是
 *            它只知道ExportFileApi接口，而不知道具体的实现。
 *     采用模式方案：  com.alby.dp.factorymethod.example3
 *  认识工厂方法模式
 *      1：工厂方法模式的功能
 *              工厂方法的主要功能是让父类在不知道具体实现的情况下，完成自身的功能调用，
 *           而具体的实现延迟到子类来实现
 *      2：实现成抽象类
 *              工厂方法的实现中，通常父类是一个抽象了，里面包含创建所需对象的抽象方法，
 *            这些抽象方法就是工厂方法
 *              //既要约束子类的行为，又要为子类提供公共的功能使用抽象类
 *      3：实现成具体的类
 *              也可以把父类实现成为一个具体的类，这种情况下，通常是在父类中提供获取所需
 *             对象的默认实现方法，这样就算没有具体的子类，也能够运行。
 *      4：工厂方法的参数和返回值
 *              工厂方法的实现中，可能需要参数，以便决定到底选用哪一种具体的实现。
 *              一般工厂方法返回的是被创建对象的接口对象，当然也可以是抽象类或者一个具体的类的实例
 *      5：谁来使用工厂方法创建的对象
 *          （1）在工厂方法模式里面，应该是Creator中的其他方法在使用工厂方法创建的对象
 *          （2）客户端应该是使用Creator对象，或者是使用由Creator创建出来的对象，这个时候
 *              工厂方法创建的对象，是Creator中某些方法使用
 *          （3）在某些情况下，客户端可能会使用由Creator创建出来的对象，这个时候工厂方法
 *               创建的对象，是构成客户端需要 的对象一部分
 *                      com.alby.dp.factorymethod.example4
 *        在工厂方法模式里面，客户端要么使用Creator对象，要么使用Creator创建的对象，一般客户端
 *        不直接使用工厂方法。当然也可以直接把工厂方法暴露给客户端，但是一般不这么做
 * 工厂方法模式的调用顺序示意图：。。。。
 *
 * 工厂方法模式与IoC/DI
 *  1：概念
 *      依赖注入：应用程序依赖容器创建并注入他所需要的外部资源
 *      控制反转：容器控制应用程序，有容器反向的向应用程序注入应用程序所需要的外部资源
 *  2：思想
 *              其他IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”
 *          的变化，应用程序原本是老大，要获取什么组员主动出击牡丹石在IoC/DI思想中，应用程序
 *          就变成被动的了，被动的等待IoC/DI容器来创建并注入他所需要的资源
 *              这么小小的一个改变其实是编程思想的一个大进步，这样就有效的分离了对象和它所需要的
 *          外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构
 *          变得非常灵活
 *工厂方法模式和IoC/DI的关系
 *      它们的思想很类似，都是“主动变被动”，进行“主从换位”，从而获得更灵活的程序结构
 *
 * 平行的类层次结构
 *          简单点说，假如两个类层次结构，其中一个类层次中的每个类在另一个类层次中都有一个对应的类
 *      的结构，被称为平行的类层次结构
 ** 作用
 *      主要用来把一个类层次中的某些行为分离出来，让类层次中的类吧原本属于自己的职责委托给
 *      分离出来的类去实现，从而使得类层次本身变得更简单，更容易扩展和复用
 *  和工厂方法模式的关系
 *      可以使用工厂方法模式来连接平行类层次
 *
 * 参数化工厂方法  com.alby.dp.factorymethod.example7
 *      是指：通过给g工厂方法传递参数，让工厂方法根据参数的不同来创建不同的产品对象 *
 *
 * 工厂方法模式的优缺点
 *      1：可以在不知具体实现的情况下编程
 *      2：更容易扩展对象的新版本
 *      3：连接平行的类层次
 *      4：具体产品对象和工厂方法的耦合性
 * 工厂方法模式的本质：延迟到子类来选择实现
 * 对设计原则的体现
 *      工厂方法模式很好的体现了“依赖倒置原则”
 *               依赖倒置原则告诉我们“要依赖抽象，不要依赖于具体类”，简单点说就是：
 *           不能让高层组件依赖于底层组件，而且不管高层组件还是底层组件，都应该依赖于抽象
 *
 * 合适选用工厂方法模式
 *      1：如果一个类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂
 *      模式，把创建对象的工作延迟到子类去实现
 *      2：如果一个类本身就希望，由他的子类来创建所需的对象的时候，应该使用工厂方法模式
 *
 *
 *
 *
 *
 *
 */
package com.alby.dp.factorymethod;