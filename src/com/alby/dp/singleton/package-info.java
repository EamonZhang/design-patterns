/**
 * Created by xianwei on 2015/11/29.
 * 单例模式示例代码  singleton
 * 定义
 *      保证一个类在运行期间只有一个实例对象，并提供一个访问它的全局访问点
 * 结构和说明
 *      Singleton
 *            unigueInstance:Singleton
 *    Singleton:
 *          负责创建Singleton类自己的唯一实例，并提供一个getInstance方法供外部访问
 *
 * 读取配置文件内容
 *      不使用模式解决方案   com.alby.dp.singleton.example3
 *          问题：由于配置文件是运行期间是不变的，如果多个地方读取配置文件，需要多次
 *                 读取，造成内存浪费，浪费系统资源
 *       使用单例模式的实现  com.alby.dp.singleton.example4
 * 理解单例模式
 *  认识单例模式
 *      1：单例模式的功能
 *              单例模式的功能是用来保证这个类在运行期间只会被创建一个类实例，并提供
 *             一个全局唯一访问这个类实例的访问点
 *      2：单例模式的范围
 *              是一个ClassLoader及其子ClassLoader的范围
 *      3：单例模式的命名
 *              一般建议单例模式的方法命名为：getInstance()
 *              单例模式的名称：单例、单件、单体等等，都指的是同一个模式
 *   懒汉式和饿汉式的实现
 *      懒汉式 com.alby.dp.singleton.example1.Singleton
 *           // 从时间空间上看，以时间换空间
 *           // 从线程安全上看，安全
 *      饿汉式 com.alby.dp.singleton.example2.Singleton
 *          // 以空间换时间
 *          // 不安全
 *   延迟加载的思想
 *      通俗点说，就是一开始不要加载资源或者数据，一直等到马上要使用这个资源或者数据了
 *      躲不过去了才加载，所以也称为 Lazy Load，不是懒惰，是“延迟加载”，这在实际开发
 *      中是一种常见的思想，尽可能的节约资源。
 *   缓存的思想
 *      单例模式的懒汉式实现还体现了缓存的思想，缓存也是在实际开发非常常见的
 *      简单讲，如果某些资源或者数据会被频繁的使用，可以吧这些数据缓存到内存里面，每次
 *      操作的时候，先到内存里面找，看有没有这些数据，如果有，那么就直接使用，如果没有
 *      那么就获取他，并设置到缓存中，一下次访问的时候就可以直接从内存中获取了，从而节省
 *      大量的时候，缓存是一种典型的空间换时间的方案
 *   Java中缓存的基本实现
 *          com.alby.dp.singleton.example5.JavaCache
 *   利用缓存来实现单例模式
 *          com.alby.dp.singleton.example6.Singleton
 *   单例模式的优缺点
 *      1：时间和空间：懒汉式是典型的时间换空间，饿汉式是典型的空间换时间
 *      2：线程安全：（1）不加同步的懒汉式是线程不安全的
 *                   （2）饿汉式是线程安全的，因为虚拟机保证了只会装载一次
 *                   （3）实现懒汉式线程安全   加上 synchronized 即可
 *                   （4）双重检查加锁
 *                          com.alby.dp.singleton.example7.Singleton
 *                      所谓双重检查加锁的机制，指的是：并不是每次进入getInstance方法都
 *                    需要同步，而是先不同步，进入方法过后，先检查实例是否存在，如果不存在
 *                    才进入下面的同步快，这是第一重检查，进入同步快后，再次检查实例是否
 *                    存在，如果不存在，就在同步情况下创建一个实例，这是第二重检查，这样一来
 *                    就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间
 *                      双重检查加锁机制的实现会使用一个关键字valatile，它的意思是：被volatile
 *                     修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享
 *                     内存，从而确保多个线程能正确的处理该变量。
 *                          注意：在Java1.4及以前的版本中，很多JVM对于volatile关键字的实现由问题
 *                          会导致双重检查加锁的失败，因此本机制只能在Java5及以上版本
 *  在Java中一种更好的单例实现方式
 *          com.alby.dp.singleton.example8.Singleton
 *      Lazy initialzation holder class 模式，这个模式综合使用了Java的类级内部类和多线程
 *      缺省同步锁的知识，很巧妙的同时实现了延迟加载和线程安全。
 *  单例和枚举
 *          com.alby.dp.singleton.example9.Singleton
 *      单元素的枚举类型已经成为实现Singleton的最佳方法
 * 思考单例模式
 *  单例模式的本质：控制实例数目
 * 何时选用单例模式
 *  当需要控制一个类的实例只能有一个，而且客户只能从一个全局访问点访问他时，可以选用单例模式，
 *  这些功能恰好时单例模式要解决的问题
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
package com.alby.dp.singleton;