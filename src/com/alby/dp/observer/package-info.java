/**
 * Created by xianwei on 2015/12/5.
 * 观察者模式  Observer
 * 定义
 *      定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖它的对象都得到通知
 *      并被自动更新
 * 结构和说明
 *      Subject：
 *          目标对象，通常具有如下功能：
 *              （1）一个目标可以被多个观察者观察
 *              （2）目标提供对观察者注册和退订的功能
 *              （3）当目标的状态发生变化是，目标负责通知所有注册的、有效的观察者
 *      Observer：
 *          定义观察者的接口，提供目标通知时对应的更新方法，这个更新方法进行相应的业务处理，可以
 *         在这个方法里面回调目标对象，以获取目标对象的数据
 *     ConcreteSubject：
 *          具体的目标实现对象，用来维护目标的状态，当目标对象的状态发生改变时，通知所有注册有效
 *        的观察者，让观察者执行相应的处理
 *     ConcreteObserver：
 *          观察者的具体实现对象，用来接收目标的通知，并进行相应的后续处理，比如更新自身的状态
 *        以保持和目标的相应状态一致。
 *  案例：
 *      订阅报纸的过程：
 *      订阅报纸的问题：
 *          订阅者在完成订阅后，最关系的问题就是何时能收到新出的报纸，幸好在现实生活中，报纸
 *          都是定期出版，这样发放到订阅者手中也基本上有一个大致的时间范围，差不多到时间了，
 *          订阅者就会看看邮箱，查收新的报纸
 *          要是报纸出版的时间不固定，那订阅者就麻烦了，如果订阅者想要第一时间阅读到新报纸，
 *          恐怕就只能天天守着邮箱了，
 *          用类来描述上述过程：
 *              订阅者类向出版者类订阅报纸，很明显不会只有一个订阅者订阅报纸，订阅者类可以有很多
 *           当出版者类出版新的报纸的时候，多个订阅者类如何知道，如何的到新报纸的内容。
 *           抽象描述这个问题：当一个对象的状态发生改变的时候，如何让依赖于它的所有对象得到通知，
 *           并进行相应的处理？
 *
 *           com.alby.dp.observer.example2
 *
 *  认识观察者模式
 *       1：目标和观察者之间的关系
 *          目标和观察者之间是典型的一对多的关系
 *          但是要注意,如果观察者只有一个，也是可以的，这样就变相的实现了目标和观察者之间一对一
 *          的关系，这也使得在处理一个对象的状态变化会影响到另一个对象的时候，也可以考虑使用观察
 *          者模式
 *          同样的，一个观察者也可以观察多个目标，如果观察者为多个目标定义的通知更新方法都是
 *          update方法的话，这会带来麻烦，因为需要接收多个目标的通知，如果是一个update的方法，
 *          那就需要在方法内部区分，到底这个更新的通知来自于哪一个目标，不同的目标有不同的后续
 *          操作
 *          一般情况下，观察者应该为不同的观察者目标，定义不同的回调方法，这样实现最简单，不需要
 *          在update方法内部进行区分
 *      2：单项依赖
 *          在观察者模式中，观察者和目标单项依赖的，只有观察者依赖于目标，而目标是不会依赖于观察者的
 *          它们之间联系的主动权掌握在目标手中，只有目标知道什么时候需要通知观察者，在整个过程
 *          中，观察者始终是被动的，被动的等待目标的通知，等待目标传至给它
 *          对目标而言，所有的观察者都是一样的，目标会一视同仁的对待。当然也可以通过在目标里面
 *          进行控制，实现有区别对待观察者，比如某些状态变化，只需要通知部分观察者，但那是属于
 *          稍微变形的用法了，不属于标准、原始的观察者模式了
 *      3：基本的实现目标
 *              具体的目标实现对象要维护观察者的注册信息，最简单的实现方案就如同前面的例子，采用一个
 *           集合来保存观察者的主粗信息
 *               具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自身状态，变形使用的
 *           情况下，也可以是别的对象的状态
 *                具体的观察者实现对象需要能接收目标的通知，能够接收目标传递的数据，或者是能够
 *            主动去获取目标的数据，并进行后续处理
 *                 如果是一个观察者观察多个目标，那么在观察者的更新方法里面，需要去判断来自哪一个
 *              目标的通知。一个简单的解决方案就是扩展update方法，比如在方法里面多传递一个参数
 *              进行区分等；还有一种更简单的方法，那就是干脆定义不同的回调方法。
 *       4：命名建议
 *          （1）观察者模式又被称为发布-订阅模式
 *          （2）目标接口的定义，建议在名称后面跟Subject
 *          （3）观察者接口的定义，建议在名称后面跟Observer
 *          （4）观察者接口的更新方法，建议名称为update，当然方法的参数可以根据需要定义，参数个数
 *              不限，参数类型不限
 *       5：触发通知的时机
 *              一般情况下，是在完成了状态维护后触发，因为通知会传递数据，不能够先通知后改数据，
 *           这很容易出问题，会导致观察者和目标对象的状态不一致。
 *       6：相互观察
 *              A对象的状态变化会引起C对象的联队操作，反过来，C对象的状态变化也会引起A对象的
 *            联动操作，对于出现这种情况，要特别小心处理，因为可能会出现死循环的情况
 *      7：观察者模式的调用顺序示意图。。。。
 *              在使用观察者模式时，会很明显的分成两个阶段，第一个阶段时准备阶段，也就是维护目标
 *           和观察者关系的阶段
 *              接下来就是实际运行阶段
 *      8：通知的顺序
 *              从理论上来说，当目标对象的状态变化后通知所有的观察者的时候，顺序是不确定的，
 *          因此观察者实现的功能，绝对不要依赖于通知的顺序，也就是说，多个观察者之间的功能
 *          是平行的，相互不应该有先后的依赖关系
 *  推模型和拉模型
 *      推模型：目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是
 *              目标对象的全部或部分数据，相当于是在广播通信。
 *              com.alby.dp.observer.example3
 *      拉模型：目标对象在通知观察者的时候，只传递少量信息，如果观察者需要更具体的信息，由观察
 *              这主动到目标对象中获取，相当于是观察者从目标中拉数据
 *              一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者
 *              需要获取数据的时候，就可以通过这个引用来获取了
 *    关于两种模型的比较
 *          两种实现模型，在开发的时候，究竟应该使用哪一种，还应该具体问题具体分析，
 *          1：推模型是假定目标对象知道观察者需要的数据；而拉模型是目标对象不知道观察者具体需要
 *          什么数据，没办法的情况下，干脆把自身传给观察者，让观察者自己去按需取值
 *          2：推模型可能会使得观察者对象难以复用，因为观察者定义的update方法是按需而定义的，
 *          可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能按需要提供新的
 *          update方法，或者干脆重新实现观察者
 *              而拉模型就不会造成这样的情况，因为拉模型下，update方法的参数是目标对象本身，这
 *          基本上是目标对象能传递的最大集合了，基本上个可以适应各种情况的需要
 * Java中的观察者模式
 *      在java.util包里面有一个类Observable，它实现了大部分我们需要的目标的功能；还有一个接口
 *   Observer，它里面定义了update的方法，就是观察者的接口
 *       com.alby.dp.observer.example4
 *  Swing中的观察者模式
 *          Swing中到处都是观察者模式的身影，比如大家熟悉的事件处理，就是典型的观察者模式的应用。
 *          （说明一下：早期的Swing事件处理用的是职责链）、
 *          Swing组件是被观察的目标，而每个实现监听器的类就是观察者，监听器的接口就是观察者的
 *       接口，在调用addXXXListener方法的时候就相当于注册观察者
 *          当组件被点击，状态发送改变的时候，就会产生相应的通知，会调用注册的观察者的方法，
 *       就是我们所实现的监听器的方法。
 *  观察者模式的优缺点：
 *      1：观察者模式实现了观察者和目标之间的抽象耦合
 *      2：观察者模式实现了动态联动
 *      3：观察者模式支持广播通信
 *      4：观察者模式可能会引起无谓的操作
 *  观察者模式的本质：触发联动
 *  何时选用观察者模式
 *      1：当一个抽象模型有两个方面，其中一个方面的操作依赖于另一个方面的状态变化，那么就可以
 *          选用观察者模式
 *      2：如果在更改一个对象的时候，需用同时连带改变其他的对象，而且不知道究竟应该有多少对象
 *          需要被连带改变，这种情况可以选用观察者模式，被更改的哪一个对象很明显就相当于是目标
 *          对象，而需要连带修改的多个其他对象，就作为多个观察者对象了。
 *      3：当一个对象必须通知其他的对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的，
 *          也就是说这个对象其实不想知道具体被通知的对象，这种情况可以选用观察者模式，这个对象
 *          就相当于是目标对象，而被它通知的对象就是观察者对象了。
 *  简单变形示例----区别对待观察者
 *      1：范例需求
 *          这是一个实际系统的简化需求：在一个水质监测系统中有这样一个功能，当水中的杂质为正常
 *          的时候，只是通知监测人员做记录；当为轻度污染的时候，除了通知检测人员做记录外，还要
 *          通知预警人员，判断是否需要预警；当为中度或者高度污染的时候，除了通知监测人员做记录外，
 *          还要通知预警人员，判断是否需要预警，同时还要通知监测部门领导做相应的处理
 *      2：解决思路和范例代码
 *              分析上述需求就会发现，对于水质污染这件事情，有可能会涉及到监测员、预警人员、
 *          监测部门领导他们三者是平行的，职责都是处理水质污染，但是处理的范围不一样。
 *              因此很容易套用上观察者模式，如果把水质污染的记录当作被观察的目标的话，那么
 *          监测员、预警人员和监测部门领导就都是观察者了。
 *              前面学过的观察者模式，当目标通知观察者的时候是全部都通知，但是现在这个需求是
 *           不同的情况来让不同的人处理。
 *              解决的方式通常有两种，一种是目标可以通知，但是观察者不做任何操作；另外一种是
 *           在目标里面进行判断，干脆就不通知了。两种实现方式各有千秋，这里选择后面一种方式
 *           来实例，这种方式能够统一逻辑控制，并进行观察者的统一分派，有利于业务控制和今后的扩展
 *      com.alby.dp.observer.example5
 *
 *
 *
 *
 *
 *
 *
 *
 */
package com.alby.dp.observer;