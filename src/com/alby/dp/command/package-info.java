/**
 * Created by xianwei on 2015/12/6.
 * 命令模式     Command
 *    定义：
 *          将一个请求分装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录
 *      请求的日志，以及支持可撤销的操作。
 *    结构和说明
 *          Command：定义命令的接口，声明执行的方法
 *          ConcreteCommand：
 *              命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成
 *            命令要执行的操作
 *          Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现
 *              命令要求实现的相应功能
 *          Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多得命令对象。这是客户
 *              端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
 *          Client：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的
 *              客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，
 *              因为真正使用命令的客户端是从Invoker来触发执行。
 *  案例：
 *      如何开机
 *              当我们按下启动按钮过后呢？谁来处理？如何处理？都经历了怎样的过程，才让电脑真正的启动
 *          起来，供我们使用
 *          使用软件吧开机的过程表现出来：
 *              首先把开机的过程总结一下，主要就这么几个步奏：首先加载电源，然后是设备检查，再然后
 *          是装载系统，最后电脑就正常启动了。可是谁来完成这些过程？如何完成？
 *              真正完成这些工作的是主板，那么客户和主板如何发生联系呢？现实中，是用连接线吧按钮连接
 *          到主板上的，这样当客户按下按钮的时候，就相当于发命令给主板，让主板去完成后续的共组
 *              另外，从客户的角度来看，开机就是按下按钮，不管什么样的主板都是一样的，也就是说，
 *          客户只管发出命令，谁接收命令，谁实现命令，如何实现，各户并不关心
 *      有何问题
 *              把上面的问题抽象描述一下：客户端只是想要发出命令或者请求，不关心请求的真正接收者
 *          是谁，也不关心具体如何实现，而且同一个请求的动作可以有不同的请求内容，当然具体的处理
 *          功能也不一样，请问该如何实现？
 *
 *     使用模式的解决方案
 *     解决思路
 *              在命令模式中，会定义一个命令接口，用来约束所有的命令对象，每个命令实现对象是
 *          客户端某个请求的封装，对应机箱上的按钮，一个机箱上的可以有很多按钮，也就相当于会有
 *          多个具体命令的实现对象
 *              在命令模式中，命令对象并不知道如何处理命令，会有响应的接收者对象来真正执行命令。
 *          就像电脑的例子，机箱上的按钮并不知道如何处理功能，而是把这个请求转发给主板，由主板
 *          来执行真正的功能，这个主板就相当于命令模式的接收者。
 *              在命令模式中，命令对象和接收对象的关系，并不是与生俱来的，需要有一个装配的过程
 *          ，命令模式中的Client对象就来实现这样的功能，这就相当于在电脑的例子中有了机箱上的按钮，
 *          也有了主板，还需要一个连接线把这个按钮连接到主板上才行
 *              命令模式还会提供一个Invoker对象来持有命令对象，就像电脑的例子，机箱上会有多个按钮
 *          这个机箱就相当于命令模式的Invoker对象，这样一来命令模式的客户端就可以通过Invoker来触发
 *          并要求执行相应的命令了，这就相当于真正的客户是按下机箱上的按钮来操作电脑一样
 *      com.alby.dp.command.example2
 *  认识命令模式
 *      1：命令模式的关键
 *          命令模式的关键之处就是把请求封装成对象，也就是命令对象，并定义了统一的执行操作的接口，
 *       这个命令对象可以被存储，转发、记录、处理、撤销等、整个命令模式都是围绕这个对象在进行
 *      2：命令模式的组装和调用
 *          在命令模式中经常会有一个命令的租转者，用来维护命令的"虚"实现和真实实现之间的关系。
 *        如果是超级智能的命令，也即是说命令对象自己完全实现好了。不需要接收者，那就是命令模式
 *        的退化，不需要接收者，自然也不需要组装者了。
 *          而真正的用户就是具体化请求的内容，然后提交请求进行触发就好。真正的用户会通过invoker
 *        来触发命令
 *          在实际开发中，Client和Invoker可以融合在一起，由客户在使用命令模式时，先进行命令对象
 *         和接收者的组装，组装完成后，再调用命令执行请求
 *      3：命令模式的接收者
 *              接收者可以是任意的类，对它没有什么特殊要求，这个对象知道如何真正执行命令的操作，
 *          执行时是从command的实现类里面转调过来。
 *              一个接收者对象可以处理多个命令，接收者和命令之间没有约定的对应关系。接收者提供的
 *           方法个数、名称、功能和命令中的可以不一样，只要能够通过调用接收者的方法来实现命令对应
 *           的功能就可以了
 *      4：智能命令
 *                  在标准的命令模式里面，命令的实现类是没有真正实现命令要求的功能的，真正执行命令
 *              的功能的是接收者。
 *                  如果命令的实现对象比较智能，他自己就能真实的而实现命令要求的工鞥，而不再需要
 *              调用接收者，那么这种情况就称为智能命令。
 *                  也可以有半智能的命令，命令对象知道到部分实现，其他的还是需要调用接收者来完成，
 *               也就是说命令的功能由命令对象和接收者共同来完成
 *      5：发起请求的对象和真正实现的对象是解耦的
 *
 *
 *
 *
 *
 *
 *
 *
 */
package com.alby.dp.command;