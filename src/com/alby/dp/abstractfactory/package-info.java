/**
 * Created by xianwei on 2015/11/30.
 * 抽象工厂模式   Abstract Factory
 * 定义：
 *      提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
 * 类说明：
 *      AbstractFactory     抽象工厂，定义创建一系列产品对象的操作接口
 *      ConcreteFactory     具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建
 *      AbstractProduct     定义一类产品对象的接口
 *      ConcreteProduct     具体的产品实现对象，通常在具体工厂里面，会选择具体的产品实现对象
 *                          来创建符合抽象工厂定义的方法返回的产品类型的对象
 *      Client              客户端，主要使用抽象工厂来获取一系列所需要产品，然后面向这些产品
 *                          对象的接口编程，以实现需要的功能
 * 案例：电脑装机
 *      不使用模式的解决方案：com.alby.dp.abstractfactory.example2
 *          问题：虽然上面的实现，通过简单工厂解决了：对于装机工程师，只知道CPU和主板的接口，而
 *                不知道具体实现的问题。但还有一个问题没有解决，就是这些CPU对象和主板对象其实是
 *                有关系的，是需要相互配合的
 *      使用模式的解决方案：
 *          思路：装机工程师要组装电脑对象，需要一系列的产品对象，比如CPU、主板等，于是创建一个
 *              抽象工厂给装机工程师使用，在这个抽象工厂里面定义抽象的创建CPU和主板，这个抽象工厂
 *              就相当于一个抽象的装机方案，在这个装机方案里面，这个配件是能够相互匹配的。
 *                  每个装机的客户，会提出他们自己的具体装机方案，或者是选择已有的装机方案，相当于
 *               为抽象工厂提供具体的子类，在这些具体的装机方案类里面，会创建具体的CPU和主板实现对象
 *
 * 认识抽象工厂模式
 *  1：功能
 *          为一系列相关对象或相互依赖的对象创建一个接口。
 *          从某种意义上看，抽象工厂其实就一个产品的系列或产品族
 *  2：实现成接口
 *          AbstractFactory在Java中通常实现成为接口，而不是抽象类
 *  3：使用工厂方法
 *          AbstractFactory定义了创建产品需要的接口，具体的实现是在实现类里面，通常在实现类里面就需要
 *          选择多种更具体的实现，所以AbstractFactory定义的创建产品的方法也可以看成是工厂方法，而
 *          这些工厂方法的具体实现就延迟到了具体的工厂里面，也就是说使用工厂方法来实现抽象工厂
 *  4：切换产品簇
 *          抽象工厂定义了一个产品簇，因此切换产品簇的时候提供不同的抽象工厂就好了
 *  5：抽象工厂模式的调用时序图
 * 定义可扩展的工厂
 *          在前面的示例中，抽象工厂为每一种他能创建的产品对象都定义了相应的方法，比如创建CPU的方法
 *      和创建主板的方法等。
 *          这种实现有一个麻烦，就是如果在产品簇中要新增一种产品，比如现在要求抽象工厂除了能够创建
 *       CPU和主板外，还要能够创建内存对象，那么就需要在抽象工厂里面添加创建内存的这么一个方法，
 *       当抽象工厂一发生变化，所有的具体工厂实现都要发生变化，这非常不灵活
 *          现在有一种相对灵活，但是不太安全的改进方式来解决这个问题，思路如下：
 *              com.alby.dp.abstractfactory.example4
 *              抽象工厂里面需要定义那么多方法，定义一个方法就可以了，给这个方法设置一个参数，通过
 *           这个参数来判断具体创建什么产品对象；由于只有一个方法，在放回类型上就不能是具体的某个产品
 *           类型了，只能是所有的产品对象都继承或实现的这么一个类型，比如让所有的产品都实现某个接口，
 *           或者干脆使用Object类型
 * 抽象工厂和DAO
 *    一：DAO知识回顾
 *      1：DAO：数据访问对象，是Data Access Object首字母的简写
 *      2：DAO是J2EE中的一个标准模式，通过它来解决访问数据对象所面临的一系列问题，比如：数据源不同，存储
 *         类型不同，访问方式不用、供应商不同、版本不同等等，这些不同会造成访问数据的实现上差别很大
 *      3：使用DAO的系统结构图
 *                      以统一的方式              访问数据仓库
 *          业务对象 ------------------> DAO ---------------------->数据仓库
 *                       访问DAO                  来存取数据
 *      4：DAO需要抽象和封装所有对数据的访问，DAO承担和数据仓库交互的职责，也意味着，访问数据所面临的
 *         所有问题，都需要DAO在内部来自行解决
 * DAO和抽象工厂的关系
 *      在实现DAO模式的时候，最常见的实现策略就是使用工厂的策略，而且多是通过抽象工厂模式来实现，
 *      当然在使用抽象工厂模式来实现的时候，可以结合工厂方法模式。因此DAO模式和抽象工厂模式有很多得联系
 * DAO模式采用工厂方法模式来实现的策略....
 * DAO模式采用抽象工厂模式来实现的策略
 *      com.alby.dp.abstractfactory.example5
 *      com.alby.dp.abstractfactory.example6
 * 抽象工厂模式的优缺点
 *      1：分离接口和实现
 *      2：使得切换产品簇变得容易
 *      3：不太容易扩展新的产品
 *      4：容易造成类层次复杂
 * 抽象工厂模式的本质：选择产品簇的实现
 * 何时选用抽象工厂模式
 *      1：如果希望一个系统独立于它的产品的创建，组合和表示的时候，即一个系统只知道产品的接口，
 *          而不关心实现的时候
 *      2：如果一个系统要由多个产品系列中的一个来配置的时候，即：可以动态切换产品簇的时候
 *      3：如果要强调一系列相关产品的接口，以便联合使用它们的时候
 *
 *
 *
 *
 *
 *
 *
 */
package com.alby.dp.abstractfactory;