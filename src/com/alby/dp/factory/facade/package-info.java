/**
 * Created by xianwei on 2015/11/27.
 * 外观模式示例代码 （Facade [fei sei de]）
 * 定义：
 *      为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口
 *      使得这一子系统更加容易使用
 *结构和说明
 *      Client --->  Facade     |----->模块A
 *                              |----->模块B
 *                              |----->模块C
 *                     ------子系统--------------------
 * Facade：定义子系统的多个模块对外的高层接口，通常需要调用内部多个模块，从而吧客户的
 *          请求代理给适当的子系统对象
 * 模块：接收Facade对象的委派，真实实现功能，各个模块之间有交互
 *      注意：Facade对象知道各个模块，对各个模块不应该知道Facade对象
 *
 * 代码生成的应用
 *      代码生成工具
 *              表现层生成模块
 *              逻辑层生成模块
 *              数据层生成模块
 *              配置管理模块
 *   客户端需要使用代码生成工具时，
 *      未使用模式时   代码路径：com.alby.dp.factory.facade.example1
 *         存在问题
 *              客户端为了使用生成代码的功能，需要与生成代码子系统内部的多个模块交互
 *      使用模式时   代码路径： com.alby.dp.factory.facade.example
 *理解外观模式
 *  认识外观模式
 *      1. 外观模式的目的：
 *              外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统
 *           内多个模块的交互，松散耦合，从而让外部能够更简单的子系统
 *      2.使用外观跟不适用外观相比有什么变化
 *              Facade方便了客户端的调用、封装了系统内部的细节功能、实现了功能的共享和
 *            复用
 *      3. 有外观，但是可以不适用。
 *      4. 外观提供了缺省的功能实现
 *      5. 外观模式调用顺序。。。
 *  外观模式的实现
 *      1. 将外观类当成辅助工具类实现（可实现为单例）
 *      2. Facade可以实现为一个interface
 *             代码：com.alby.dp.factory.facade.example5
 *      3. Facade实现成为interface的附带好处
 *          能够有选择性的暴露接口方法，尽量减少模块对子系统外提供的接口方法
 *      4. Facade的方法实现
 *              Facade的方法实现中，一般是负责吧客户端的请求转发给子系统内部的各个模块进行
 *          处理，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能
 *          的组合调用
 * 外观模式优缺点
 *      1. 松散耦合（客户端和子系统各个模块）
 *      2. 简单易用
 *      3. 更好的划分访问的层次
 *      4. 过多的或者是不太合理的Facade也容易让人迷惑
 *外观模式的本质
 *      外观模式的本质是：封装交互，简化调用
 *对设计原则的体现
 *      体现了“最少知识原则”
 *何时选用外观模式
 *      1. 如果希望为一个复杂的子系统提供一个简单接口的时候，可以考虑使用外观模式，
 *          使用外观对象来实现大部分客户需要的功能，从而简化客户的使用
 *      2. 如果想让客户程序和抽象类的实现部分松散耦合，可以考虑使用外观模式，使用外观对象
 *          来将这个子系统与他的客户分离开来，从而提高子系统的独立性和可移植性
 *      3. 如果构建多层结构的系统，可以考虑使用外观模式，使用外观对象作为每层的入口
 *          这样可以简化层间调用，也可以松散层次之间的依赖关系

 */
package com.alby.dp.factory.facade;